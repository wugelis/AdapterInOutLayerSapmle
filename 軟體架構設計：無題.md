# 軟體架構設計：無題

![Hexagonal Architecture](https://i.imgur.com/bMOS6cv.png)
Logo 圖片取自：https://reflectoring.io/spring-hexagonal/

## 前言

為什麼叫做無題？因為軟體架構設計是一個相當龐大的主題，也不可能在一篇文章中談完，先前我也曾寫過許多架構設計系列文、包括領域驅動設計 DDD 與 整潔架構 Clean Architecture 與如何在以上的軟體架構為基礎來落實 TDD。

今天，我在以更廣泛與更實務的角度來探討軟體的架構設計，文之中也會搭上我這些年來所設計的框架、Framework 並對上也是這些年後來所讀的相關書籍、像是 DDD 領域驅動設計、Uncle Bob 的 整潔架構 Clean Architecture、還有正在讀的【Get You Hands Dirty on Clean Archiecture】，這這些書的洗禮之下，也在下面的文章中裡探討缺失、改善的方式，希望對於工作中正在進行架構設計或是正在進行專案規劃，但想要有個架構設計的資料可以參考的程式設計師，那麼或許您可以參考文章中的資料，或許對您有所幫助。


## 階層式架構設計的隱憂

圖（一）、常見的階層式架構
![階層式架構](https://i.imgur.com/TTJ1L8T.jpg)
傳統的階層式架構幾乎伴隨著我們好幾 10 年了，相信讀者不陌生，許多的老系統，包括我在 18 年前在流通業開發的幾個系統、以及後來10年前在X創開發設計的好幾個政府機關的系統也都是階層式架構設計。

究竟什麼是階層式架構？它與更早期講的三層式架構有些不同、比如 Windows DNA 那又是更早的跨機器架構，注意了，對是『跨機器』的軟架構，像是微軟早期 (DCOM, Distributed Component Object Model) 所以 DCOM 加上 Distribute 表示快機器、而 COM 就是跨行程。

這是早期的分散式環境，套用到現今，許多人想到的 Microservices/Docker.. 微服務等容器環境，這在跨機器的場景非常類似，但是 DCOM 需要完整的 OS 作業環境的支援、而 Microservices 微服務拜後來【VM 虛擬化技術】又再進階到【OS 作業系統虛擬化技術】之賜，使的應用程式可以包裹在更輕量化的容器環境之中，沒有作業系統啟動速度慢、占用系統支援較多等問題、更適合建構需要橫向擴展的 Cloud 雲端運算的環境中。

原歸正傳，所謂的階層式架構指的是近 10 多年來 Web 的興起，大部分系統都是 Web -> Application Server -> Database 的架構，前面的 Web 與 Application Server 在很多數企業環境中可能都在同一台，Database 當然會有獨立的伺服器主機，只不過在軟體系統中的 Data Access Layer 通常也在 Application Server 裡，而網站若運行在 IIS 上，用量不大的企業內部系統可能就放置在同一台上，有些情境因為機器的備援、或是效能，會建議拆不同的機器來執行，形成了 Three-Tier 架構。這些都是種階層式架構。

而階層式架構它一開始確實能夠切開 Web 與 Domain (領域層)[以下都簡稱 Domain] 以及 Persistence 的耦合性，因為它讓我們可以使用不同的 Web 架構而不影響 Domain 層或 Persistence，而實際存取 Database 的 Data Access Layer 似乎也能夠被各系統所共用，達到很高的共用性，如妥善的使用確實很好維護。

可是，問題來了，通常專案開發軟體不可能不修改、不維護啊！階層式架構開發最大的問題在於『資料庫導向開發』如果我今天只是要動一個 Persistence 的一個資料庫欄位 Column，這異動恐怕連同 Domain 與 Web 都要一起修改，這個架構非常容易走偏，因為建置 Domain 都得參考 Persistence 、修改 Domain 商業邏輯也得先修改你的 Persistence，很容易地到最後 Domain 與 Persistence 就牽扯在一塊。

底下，我們來看一種常見的階層式架構範例：

圖（三）、階層式架構範例
![階層式架構範例](https://i.imgur.com/Li2WrHC.jpg)

我仔細地來解說，這個系統分為前端 WebUI、領域層 (Domain.Employee)、與 儲存實體層 (PersistenceLayered) 這三層，Domain.Employee 會直接參考 PersistenceLayered，然後通常 WebUI 可能會同時參考 Domain.Employee 與 PersistenceLayered，且很多企業端會認為 WebUI必須同時參照兩者，甚至 WebUI 也需要同時安裝 PersistenceLayered 需要的 ORM 相關套件，像是 Entity Framework 等。

圖中的 Domain.Employee 的 EmployeeService.cs 其實比較像是過水的資料服務層，雖然 EmployeeRepository.cs 是定義在 PersistenceLayered 裡，但它的需求的變化完全相依 PersistenceLayered、或說會因為 PersistenceLayered 修改而跟著改變。表面上看起來是抽離出來的 Service 層，但事實上是完全的『資料驅動式設計』對吧？

這樣的程式碼是不是非常的常見？其實包括我 8-9 年以前撰寫的『分層架構系列 / 轉換成 MVC 系列文』都屬於此類。

## 單一職責原則（Single Resposibility Principle, SRT）

學習軟體開發或是本身是開發者的，應該都學習過物件導向五大設計原則 SOLID (SRT, OCP, LSP, ISP, DIP) 這五大設計原則，當中的 SRT (Single Reposibility Principle) 相信是再熟悉不過的了。

此原則告訴我們：『每個類別只需要做好一件事』

這概念在初淺不過，對於單一職責的表述也是我們常聽到的一種解釋，某方面來說，也非常容易理解。

而在［Clean Architecture 實作篇］裡，我覺得解釋更好，針對 SRT 的定義其實沒有這麼初淺有著詳盡的說明，其真正的定義應該是『每一個(元件/類別)應該只有一種被修改的理由』，而不是指『任務』或是『做什麼事情』，書中也打趣說該原則應該稱作［單一理由修改原則］才對，因為元件如果只有一種理由需要被修改，到最後這個元件往往也都只做一件事情，也許因為這樣，才讓許多人對於 SRT 有著就是指『只做一件事情的假象』吧！

書中也提到，如果某個元件只有一種被修改的理由，那麼這表示如果是其他理由的話，那麼都可以不用去修改這個元件，也就是系統本身的可維護性便會提高不少，因為獨立性提高，個元件各司其職，劃分的非常清楚，只是要注意的是『元件』會因為它的依賴方向使的它得要跟著修改，也就是說，元件多一個依賴，便會增加一種可能需要被修改的原因，因為依賴關係讓彼此受牽連。

圖（三）、元件的依賴關係
![元件的依賴關係](https://i.imgur.com/WVNOb5T.jpg)

如圖三，我們可以看到元件A與元件 B 或 C 或者 D 都有著依賴關係、而且還相依於 E，因此一旦 D 或者是 B 或 C 的修改都可能影響到 A，甚至讓 A 出現異常的情儣，反倒是 E 都沒有相依於其他元件，所以可以說 E 只有一種被修改的理由。對照到整潔架構裡，E 就像是 Domain Layer 最乾淨的部分，永遠只有一種裡有需要去修改它，因為它不與任何元件套件相依。

## 在 .NET Core 改良版的 Easy Architect Framework

因為長年來進行軟體專案開發，慢慢地自己察覺到階層式架構的一些缺點，於是藉由替某客戶發展 Framework 的機會，我希望發展出一種基於 Server Component 的元件架構，其實說穿了就是種部署架構，這個 Server Component 其實是一個乾淨的 C# Class，它不參考任何的外部組件、只單純提供一種 Server Method （伺服器方法）的架構，對開發專案的 Developer 而言，不需要太高的 Skill，只要需要知道 C# 怎麼寫 Class 以及如何撰寫 Method 即可開始做專案了，也就是專案開發的門檻可降低 + 提高系統穩定性 + 容易部署 + Developer 只需要專注在『領域邏輯 / 業務邏輯』即可。

當時的 Server Component 與 Server Method 基本結構範例如下：

    using EasyArchitect.BO.ServerComponent;
    using EasyArchitect.Core;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Threading.Tasks;


    namespace Domain.Soft
    {
        /// <summary>
        /// BO Server Component
        /// <summary>
        [WriteLog(UseLogType.ToFileSystem)]
        [WriteExceptionLog(UseLogType.ToEventLog)]
        public class Service : ServerComponentBase
        {
            //請在Login Method裡面撰寫Login邏輯，此名稱與參數不可更改。
            /// <summary>
            /// Login邏輯
            /// </summary>
            /// <param name="UserInfo">使用者相關資訊</param>
            /// <returns></returns>
            [EnabledAnonymous(true)]
            [ExposeWebAPI(true)]
            public bool Login(UserInfo param)
            {
                return true;
            }

            /// <summary>
            /// 基本範例，取得目前時間
            /// </summary>
            /// <param name="param"></param>
            /// <returns></returns>
            [EnabledAnonymous(true), ExposeWebAPI(true)]
            public DateTime GetDateTime(decimal param)
            {
                return DateTime.Now;
            }
        }
    }

範例程式較為簡單，只有一個 Login() 方法與一個 GetDateTime() 方法，該框架的好處就是，Developer 只需要撰寫 C# Method 後，框架的 ApiHostBase 會自動將其開放為 Web API 方法，開發人員無須關心所有與 JSON 序列化相關的問題。

我以一張圖來演示這個架構。

圖（四）、Easy Architect 的 Server Component 架構圖
![Easy Architect 的 Server Component 架構圖](https://i.imgur.com/LyF87E7.jpg)

如圖中，我的 Server Componenet 的 Server Method 其實是透過 Reflection 來 Invoke 目標方法的，好處是充分發揮類似 Domain Object 的效果，因為 Server Component 如同 Domain Layer 只需要乾淨的 Class 負責描述一個充血物件，但如果仔細對照書中解釋，這個架構也仍然沒有完全遵循 Clean Architecture 的精神，怎麼說呢？

第一是，Server Method 並沒有一種 Adapter (in/out) 機制［六角架構術語］的設計，

第二是、如果 Server Method 回傳了 ORM 的 Entity 回來，就會導致 Server Component/Domain Object 相依外圈的 Persistance Layer 了。

第三是、我並未提供依賴反轉機制、也未提供 DI 依賴注入的功能在裡面。

第四是、Server Componenet 有一個父類別、這增加了 Domain 複雜性，還不夠純淨。

所以看似美好的開發，還是很容易一個不小心就陷入書中所提及的『不小心就偷吃步了』。

針對這些問題，我後來在 .NET Core 上另外實作了一個全新的版本，這個版本可以讓 Server Component 真的是非常乾淨的 Class ，如下範例程式：

    using EmployeeViewObjects;
    using System;
    using System.Linq;
    using System.Collections.Generic;

    namespace HelloWorldBO
    {
        public class EmployeeService
        {
            public string GetHelloWorld()
            {
                return "Hello World for Web API Framework 第三梯！";
            }

            public IEnumerable<EmployeeVO> GetEmployees(MyHelloWorldVO input)
            {
                return new EmployeeVO[] {
                    new EmployeeVO() { EmpId = 1, EmpChtName = $"Gelis_{input.Test}", Title = "工程師"},
                    new EmployeeVO() { EmpId = 2, EmpChtName = "Allan", Title = "工程師"}
                };
            }
        }
    }

這個做法其實就是我在 3 年開課講的 跨平台的 Web API Framework 課程的實作內容。

圖（五）、Gelis - 程式設計訓練營 - 跨平台的 Web API Framework 框架開發（第三梯）
![Gelis - 程式設計訓練營 - 跨平台的 Web API Framework 框架開發（第三梯）](https://i.imgur.com/rw1dbG5.jpg)

當時課程連結：https://mystudyway.kktix.cc/events/softshare-web-api-framework-third

這個課程時做的基本範例雛形有上在 NuGet Packages Marget 市集上。

連結：https://www.nuget.org/packages/StdEasyArchitect.Web.WebApiHostBase/

有興趣的可以下載測試看看。

## 如何在整潔架構上落實 Unit Test？

前面談完我在專案實作上的架構有哪些並未遵循 Clean Architecture 的精神，現在，我們來談談測試好了，書中的第七章有提及架構測試，而這便我針對『領域實體』的單元測試來做討論，因為測試的方法論如果是談 TDD 那真是博大精深，先前我有一篇文章：『您的軟體架構夠敏捷嗎？（三）- 使用 TDD 實現最後的設計』便是探討這個部分，透過測試來分析需求應該是軟體開發中掌握設計同時使程式碼隨時重構在輕量可測試、高可維護性的唯一解法了，只是怎麼搭配 Clean Architecture 呢？

這邊我演示種方法。

... 我先賣個關子...

持續更新

## 待續

